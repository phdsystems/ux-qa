import type {
  ComponentInfo,
  ElementInfo,
  GeneratedTest,
  TestGeneratorOptions,
} from '../types';
import { basename, dirname, join } from 'path';

const DEFAULT_OPTIONS: TestGeneratorOptions = {
  includeVisibility: true,
  includeInteractions: true,
  includeNavigation: true,
  includeForms: true,
  includeA11y: false,
  addTodos: true,
};

export function generateTestFile(
  component: ComponentInfo,
  options: Partial<TestGeneratorOptions> = {},
  baseUrl: string = 'http://localhost:5173'
): GeneratedTest {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const tests: string[] = [];
  let testCount = 0;

  // Group elements by type
  const buttons = component.elements.filter(e => e.type === 'button');
  const links = component.elements.filter(e => e.type === 'link');
  const inputs = component.elements.filter(e => ['input', 'textarea', 'select'].includes(e.type));
  const forms = component.elements.filter(e => e.type === 'form');
  const checkboxes = component.elements.filter(e => e.type === 'checkbox');
  const radios = component.elements.filter(e => e.type === 'radio');

  // Generate visibility tests
  if (opts.includeVisibility && component.elements.length > 0) {
    tests.push(generateVisibilityTest(component));
    testCount++;
  }

  // Generate button click tests
  if (opts.includeInteractions && buttons.length > 0) {
    buttons.forEach((btn) => {
      tests.push(generateButtonTest(btn, opts.addTodos));
      testCount++;
    });
  }

  // Generate link navigation tests
  if (opts.includeNavigation && links.length > 0) {
    links.forEach((link) => {
      tests.push(generateLinkTest(link, opts.addTodos));
      testCount++;
    });
  }

  // Generate form tests
  if (opts.includeForms && forms.length > 0) {
    forms.forEach((form, index) => {
      tests.push(generateFormTest(form, inputs, index, opts.addTodos));
      testCount++;
    });
  }

  // Generate input tests
  if (opts.includeInteractions && inputs.length > 0 && forms.length === 0) {
    inputs.forEach((input) => {
      tests.push(generateInputTest(input, opts.addTodos));
      testCount++;
    });
  }

  // Generate checkbox/radio tests
  if (opts.includeInteractions) {
    checkboxes.forEach((cb) => {
      tests.push(generateCheckboxTest(cb, opts.addTodos));
      testCount++;
    });
    radios.forEach((radio) => {
      tests.push(generateRadioTest(radio, opts.addTodos));
      testCount++;
    });
  }

  // Generate a11y test
  if (opts.includeA11y) {
    tests.push(generateA11yTest(component));
    testCount++;
  }

  const content = generateFullTestFile(component, tests, baseUrl);
  const fileName = `${toKebabCase(component.name)}.spec.ts`;
  const testDir = dirname(component.filePath).replace('/src/', '/tests/e2e/');

  return {
    filePath: join(testDir, fileName),
    content,
    componentName: component.name,
    testCount,
  };
}

function generateFullTestFile(
  component: ComponentInfo,
  tests: string[],
  baseUrl: string
): string {
  const route = component.routes[0] || '/';

  return `import { test, expect } from '@playwright/test';

/**
 * Auto-generated tests for ${component.name}
 * Generated by @ux.qa/scanner
 *
 * Review and customize these tests before committing.
 */
test.describe('${component.name}', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('${route}');
  });

${tests.join('\n\n')}
});
`;
}

function generateVisibilityTest(component: ComponentInfo): string {
  const elementsWithTestId = component.elements.filter(e => e.testId);

  if (elementsWithTestId.length === 0) {
    // Suggest adding test IDs
    const suggestions = component.elements
      .slice(0, 5)
      .map(e => `    // Add data-testid="${e.suggestedTestId}" to ${e.type} at line ${e.line}`)
      .join('\n');

    return `  test('should render ${component.name} elements', async ({ page }) => {
    // TODO: Add data-testid attributes to elements for better test stability
${suggestions}

    // Example assertions (update selectors):
    // await expect(page.locator('[data-testid="example"]')).toBeVisible();
  });`;
  }

  const assertions = elementsWithTestId
    .map(e => `    await expect(page.locator('[data-testid="${e.testId}"]')).toBeVisible();`)
    .join('\n');

  return `  test('should render ${component.name} elements', async ({ page }) => {
${assertions}
  });`;
}

function generateButtonTest(element: ElementInfo, addTodos: boolean): string {
  const selector = element.testId
    ? `[data-testid="${element.testId}"]`
    : `button:has-text("${element.label || 'Button'}")`;

  const label = element.label || element.testId || 'button';
  const todo = addTodos ? '\n    // TODO: Add assertion for expected behavior after click' : '';

  return `  test('should handle ${label} click', async ({ page }) => {
    const button = page.locator('${selector}');
    await expect(button).toBeVisible();
    await button.click();${todo}
  });`;
}

function generateLinkTest(element: ElementInfo, addTodos: boolean): string {
  const selector = element.testId
    ? `[data-testid="${element.testId}"]`
    : `a[href="${element.href || '#'}"]`;

  const label = element.label || element.href || 'link';
  const navigation = element.href && !element.href.startsWith('#')
    ? `\n    await expect(page).toHaveURL(/${escapeRegex(element.href)}/);`
    : '';
  const todo = addTodos && !navigation ? '\n    // TODO: Add assertion for navigation result' : '';

  return `  test('should navigate via ${label}', async ({ page }) => {
    const link = page.locator('${selector}');
    await expect(link).toBeVisible();
    await link.click();${navigation}${todo}
  });`;
}

function generateFormTest(
  form: ElementInfo,
  inputs: ElementInfo[],
  index: number,
  addTodos: boolean
): string {
  const formSelector = form.testId
    ? `[data-testid="${form.testId}"]`
    : `form`;

  const fillStatements = inputs
    .map((input) => {
      const inputSelector = input.testId
        ? `[data-testid="${input.testId}"]`
        : `input[name="${input.label || 'field'}"]`;

      const value = getTestValue(input);
      return `    await page.fill('${inputSelector}', '${value}');`;
    })
    .join('\n');

  const todo = addTodos ? '\n    // TODO: Add assertion for form submission result' : '';
  const formLabel = form.testId || `form${index > 0 ? ` ${index + 1}` : ''}`;

  return `  test('should submit ${formLabel}', async ({ page }) => {
    const form = page.locator('${formSelector}');
    await expect(form).toBeVisible();

${fillStatements || '    // TODO: Fill form fields'}

    await page.click('${formSelector} button[type="submit"]');${todo}
  });`;
}

function generateInputTest(element: ElementInfo, addTodos: boolean): string {
  const selector = element.testId
    ? `[data-testid="${element.testId}"]`
    : `input[name="${element.label || ''}"]`;

  const label = element.label || element.testId || 'input';
  const value = getTestValue(element);
  const todo = addTodos ? '\n    // TODO: Add assertion for input behavior' : '';

  return `  test('should accept input in ${label}', async ({ page }) => {
    const input = page.locator('${selector}');
    await expect(input).toBeVisible();
    await input.fill('${value}');
    await expect(input).toHaveValue('${value}');${todo}
  });`;
}

function generateCheckboxTest(element: ElementInfo, addTodos: boolean): string {
  const selector = element.testId
    ? `[data-testid="${element.testId}"]`
    : `input[type="checkbox"]`;

  const label = element.label || element.testId || 'checkbox';
  const todo = addTodos ? '\n    // TODO: Add assertion for checkbox state change effect' : '';

  return `  test('should toggle ${label} checkbox', async ({ page }) => {
    const checkbox = page.locator('${selector}');
    await expect(checkbox).toBeVisible();

    // Check
    await checkbox.check();
    await expect(checkbox).toBeChecked();

    // Uncheck
    await checkbox.uncheck();
    await expect(checkbox).not.toBeChecked();${todo}
  });`;
}

function generateRadioTest(element: ElementInfo, addTodos: boolean): string {
  const selector = element.testId
    ? `[data-testid="${element.testId}"]`
    : `input[type="radio"]`;

  const label = element.label || element.testId || 'radio';
  const todo = addTodos ? '\n    // TODO: Add assertion for radio selection effect' : '';

  return `  test('should select ${label} radio', async ({ page }) => {
    const radio = page.locator('${selector}');
    await expect(radio).toBeVisible();
    await radio.check();
    await expect(radio).toBeChecked();${todo}
  });`;
}

function generateA11yTest(component: ComponentInfo): string {
  return `  test('should meet accessibility standards', async ({ page }) => {
    // Install @axe-core/playwright for comprehensive a11y testing
    // import AxeBuilder from '@axe-core/playwright';
    // const results = await new AxeBuilder({ page }).analyze();
    // expect(results.violations).toEqual([]);

    // Basic a11y checks:
    // - All images have alt text
    const images = page.locator('img:not([alt])');
    await expect(images).toHaveCount(0);

    // - All form inputs have labels
    const inputsWithoutLabels = page.locator('input:not([aria-label]):not([id])');
    await expect(inputsWithoutLabels).toHaveCount(0);
  });`;
}

function getTestValue(element: ElementInfo): string {
  const inputType = element.inputType || 'text';

  switch (inputType) {
    case 'email':
      return 'test@example.com';
    case 'password':
      return 'TestPassword123!';
    case 'tel':
      return '+1234567890';
    case 'url':
      return 'https://example.com';
    case 'number':
      return '42';
    case 'date':
      return '2024-01-01';
    default:
      return 'Test value';
  }
}

function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
